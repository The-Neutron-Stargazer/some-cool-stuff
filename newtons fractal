import numpy as np
import matplotlib.pyplot as plt

xlim, ylim = (-5, 5), (-5, 5)
max_iter = 1000
accuracy = 1e-6
resolution = 1000


def newton_fractal(f, f_prime, roots):
    real_vals = np.linspace(xlim[0], xlim[1], resolution)
    imag_vals = np.linspace(ylim[0], ylim[1], resolution)
    z = real_vals[:, None] + 1j * imag_vals

    root_map = np.zeros(z.shape, dtype=int)

    not_converged = np.ones(z.shape, dtype=bool)

    roots = np.array(roots)[:, None, None]

    for i in range(max_iter):
        z_active = z[not_converged]
        z[not_converged] = z_active - f(z_active) / f_prime(z_active)

        distances = np.abs(z - roots)

        closest_root_idx = np.argmin(distances, axis=0)

        min_distances = np.min(distances, axis=0)

        newly_converged = (min_distances < accuracy) & not_converged

        root_map[newly_converged] = closest_root_idx[newly_converged] + 1

        not_converged[newly_converged] = False

        if not np.any(not_converged):
            print(f"All points converged after {i + 1} iterations.")
            break

    plt.imshow(root_map, extent=(*xlim, *ylim), cmap="viridis", origin="lower")
    plt.colorbar(label="Root Convergence (1, 2, 3)")
    plt.show()

f = lambda z: z ** 3 - 1
f_prime = lambda z: 3 * z ** 2
roots = [np.exp(2j * np.pi * k / 3) for k in range(3)]

newton_fractal(f, f_prime, roots)
